## Category Theory for Programmers - Bartosz Milewski


<img src="img.png" width="500">

<br/>
<br/>

책 내용의 난이도가 높아 이해하지 못한 부분은 제외하고 이해한 부분을 중심으로 정리했습니다 :) <br/>
연한 텍스트는 인용구, 기본 텍스트는 저의 생각을 정리해보았습니다. :)


<br/>

#### CHAPTER01. 카테고리: 합성의 본질

>카테고리는 대상과 그 사이를 이어주는 화살표로 구성된다. 따라서 카테고리의 본질은 합성이다. 반드시 대상 A에서 C로 향하는 화살표, 즉 A->B와 B->C의 합성이 존재해야한다.

> 합성을 만족시키기 위해서는 두가지 조건이 필요하다. 바로 결합법칙 성립과 모든 대상 A에는 항등 개념을 가진 화살표가 존재해야한다는 것이다.

> 함수의 본문은 항상 표현식(expression)이며, 문(statement)은 존재하지 않는다. (반환값이 반드시 있다.)

> 즉 우아한 코드는 우리의 뇌가 처리할 수 있는 적절한 크기, 적절한 개수의 청크를 만들어내는 것이라고 볼 수 있다. 그렇다면 적합한 청크는 무엇일까? 먼저 청크의 면적은 청크의 부피보다 느리게 증가해야한다. (면적: 외부에서 필요한, 합성하는데 필요한 정보, 부피: 구체적인 구현 정보)

> 객체지향에서 면적은 클래스나 인터페이스이지만, 함수형에서는 함수의 선언이라고 볼 수 있다.

```javascript
const add = (a, b) => a + b;
```
- **면적**: add 함수의 입력과 출력은 그 면적입니다. 즉, 이 함수는 두 개의 숫자를 받아 그 합을 반환하는 역할이 면적이다.
- **부피**: add 함수 내부에서 실제로 a + b라는 덧셈이 수행되는 연산이 부피

<br/>

#### CHAPTER02. 타입과 함수
>타입체킹은 무의미하게 작성된 프로그램에 대한 하나의 방어막이다. 정적체크되는 타입 불일치는 컴파일 타임에 발견되기 때문에 굳이 실행해 보지않더라도 잘못된 프로그램을 잡아낸다.

>임의의 두 화살표를 아무렇게나 합성할 수 있는 것은 아니다. 한 화살표의 목표인 대상은 다음 화살표의 출발 대상과 동일해야한다. 즉 하ㅂ성이 제대로 되려면 양 끝단이 일치해야 한다는 것이며 타입시스템이 강력할수록 이러한 일치여부를 잘 표현하고 검증할 수 있다.

>우리가 명령형 언어에서 함수라고 부른 것들은 수학자들이 함수라고 부르는 것과는 약간 다른 개념이다. 수학적 함수는 그저 어떠한 값들 간의 사상(Mapping)일 뿐이기 때문이다.

<br/>

#### CHAPTER03. 다양한 카테고리들
>Thin 카테고리는 대상 a에서 대상 b로 가는 사상이 최대 1개만 존재하는 카테고리이다. 원순서 집합이 Thin 카테고리에 해당한다. (원순서 집합: 작거나 같다"는 관계를 나타내는 집합 a ≤ b)

> Hom 집합은 두 대상 사이의 모든 사상들의 집합이다. 예를 들어, 카테고리 C에서 대상 a와 b가 있을 때, Hom 집합은 a에서 b로 향하는 모든 사상들의 집합을 의미한다. 이를 수학적으로 C(a, b) 또는 **Hom(C, a, b)** 로 표현한다.

> 모노이드는 이항연산을 가진 집합으로 정의된다. 이 이항연산은 결합법칙을 만족해야하며 연산에 대해 상등원 같은 특별한 원소가 하나 있어야 한다. 예를 들어 0을 포함하는 자연수 집합은 덧셈에 대해 모노이드를 이룬다. 

```javascript
// 문자열 모노이드: 이항 연산은 문자열 결합, 항등원은 빈 문자열
const concat = (a, b) => a + b;
const identity = "";

// 두 개의 문자열을 결합
let result = concat("Hello, ", "World!"); // "Hello, World!"
console.log(result);

// 항등원을 사용하여 결합
let resultWithIdentity = concat("Hello", identity); // "Hello"
console.log(resultWithIdentity);
```
- 함수형 프로그래밍에서 모노이드는 데이터 결합을 다루는 데 유용하다. 예를 들어, 여러 개의 값을 결합하는 연산은 모노이드의 결합법칙과 항등원 성질을 활용하여 구현할 수 있다. 이 과정에서 불변성을 유지하면서 연산을 처리할 수 있다.

<img src="img_2.png" width="400">

>관점을 바꿔 이항연산을 적용한다는 것을 어떤 대상에서 다른 대상으로 "이동"하는 것으로 생각해보자. 어떤 수 n에 대해서 다시 n을 더하는 "Adder" 함수가 있다고 생각배호자. 이 Adder는 어떤 방식으로 합성될까? 5를 더하는 함수와 7을 더하는 함수를 합성하면 12를 더하는 함수가 될 것이다. 즉 Adder들 간의 합성은 덧셈 규칙을 그대로 유지한다고 볼  수 있다. 그렇다면 덧셈이라는 개념을 함수의 합성이라 생각해도 문제없을 것이다. 

<br/>

#### CHAPTER04. 크라이슬리 카테고리
```javascript
// Writer 모나드를 간단히 표현하기 위한 구조
function writer(value, log) {
return { value, log };
}

// isEven 함수: 숫자가 짝수인지 확인하고 로그를 남김
function isEven(n) {
const result = n % 2 === 0;
return writer(result, `Checked if ${n} is even. `);
}

// negate 함수: 논리값을 반전시키고 로그를 남김
function negate(b) {
return writer(!b, `Negated the value. `);
}

// 두 함수를 합성: 숫자를 짝수인지 확인하고 결과를 반전
function isOdd(n) {
const p1 = isEven(n);
const p2 = negate(p1.value);
return writer(p2.value, p1.log + p2.log); // 값과 로그를 합침
}

// 사용 예시
const result = isOdd(4);
console.log(result.value); // false
console.log(result.log);   // "Checked if 4 is even. Negated the value. "
```
- 순수함수를 유지하기 위해서는 메모이제이션이라는 문제가 있다. 전역없이 메모이제이션을 해가며 함수를 계속 호출해야하기 때문이다. 따라서 재귀함수가 FP 전반적으로 도입될 수 밖에 없다는 것을 깨달았다.
- Writer 모나드와 Writer 카테고리는 함수형 프로그래밍에서 사이드 이펙트를 다루는 한 방법이다.
- 특히, 순수 함수를 유지하면서도 부수적인 정보(예: 로그, 상태)를 처리할 수 있도록 도와준다.
- Writer 개념을 통해 Exception 같은 참조투명성을 깨뜨리는 행위없이 순수함수를 통해 기타정보를 처리할 수 있다.

<br/>

#### CHAPTER05. 곱과 합

>



